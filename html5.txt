HTML5
	在2004年，由一些著名的组织和个人构成了一个标准化机构，成为Web超文本应用技术工作组(Web Hypertext Application Technology Working Group WHATWG) 网址为www.whatwg.org，该组织的目标是产生一个HTML的新版本（可能由于XHTML难理解，或者是对Web标准执行慢而感到挫折，或者想创新），他们希望这个版本能为Web应用程序创建一个新的，丰富的，基于HTML的语言。由于一些新规范（canvas等）已经出现在一些浏览器(safari firefox)中，因此在2008年，这个机构努力的结果被W3C认可，并制定了草案。目前很多浏览器厂商和市场都开始承认HTML5,并且Google在很多地方都使用了HTML5，说明它的未来是光明的。

	HTML5规范不仅支持先前HTML和XHTML的语法，而且增加了新的功能，虽然与HTML4相比HTML5是一种进步，但它同样也是一个妥协，HTML5的设计者明白一个现实，就是大多数WEB开发人员因为没有经过正规的技术训练，虽然要求他们写出规范的标记代码是徒劳的。

	虽然对Web文档制作者而言，关于遵循HTML5浏览器语法分析器的应用讨论无法让他们产生兴趣，但是现在浏览器开发人员拥有一个共同的规范借以遵循，用于确定浏览器在遇到标签不嵌套，没有结束标记或者以不同的方式混杂时应该如何处理，这种功能是HTML5规范期望产生最好的结果的部分，是因为让浏览器供应商在处理标记问题上达成持久的共识比定义一些严格的语法然后让世界各地的web制作者都来比那些好的标记更能促进Web的发展。 力求使标记编写更有秩序只是H5规范的宏伟目标中的一个，它还期望以向后兼容的方式取代传统的HTML,XHTML,DOM规范。在这一目标的驱使下，当H5规范扩展时，它不仅会说明有哪些元素，并且会阐明如何在HTMLL中一个在脚本程序中使用这种元素。

	HTML5要解决的三个问题
		1. Web浏览器之间的兼容性很低
			H5的使命是详细分析各Web浏览器所具有的功能，然后以此为基础，要求这些浏览器所有内部功能都要符合一个通用标准。如果各浏览器都符合通用标准，然后以该标准为基础书写程序，那么程序在各个浏览器都能正常运行的可能性就大大提高。

		2. 文档结构不够明确
			H5中添加了很多跟结构相关的元素，例如header,footer,section,article

		3. Web应用程序功能受到限制
			H5提供了各种各样Web应用上的新API，各个浏览器也在快速地封装着这些API。H5已经使富Web应用的实现变成了可能。

1. 第一个HTML文档
	<!DOCTYPE html>
	<html lang="en">
	<head>
	    <meta charset="UTF-8">
	    <title>Html5文档</title>
	    <script src=""></script>
	    <style>

	    </style>
	</head>
	<body>

	</body>
	</html>

		1) DOCTYPE
		<!DOCTYPE>与之前的HTML4有很大区别，原因是HTML5并不是定义为SGML或者XML的应用程序，在HTML5中不存在有效性检查，取而代之的是根据规范来了检查规范的一致性（让浏览器按照它们应该的方式来运行）。HTML4.01中的doctype需要对DTD进行引用，因为HTML4.01基于SGML。

		SGML  标准通用标记语言-- XML -- HTML

	2) 松散语法
		在HTML4中允许的标记形式，在HTML5中也是可行，但是推荐遵守HTML5的规范：
		1. 元素之间应该是嵌套关系而不是交叉关系
		2. 遵循内容模型，比如不要单独使用li，应该配合ul>li
			<li>hello</li>
		3. 不要使用自定义标签
			<select-option></select-option>
		4. 特殊字符进行编码时可以采用名称实体的形式 例如
			&lt;	<
			&gt;	>
			&nbsp;  空格
			...


	3) 删除/重新定义标记
		H5删除了一些元素和特性，这些元素被删除的原因是它们更倾向于描述外观而不包含语法意义。虽然在规范中这些元素已经被删除，但是浏览器仍然会支持这些元素，我们应该避免使用它们，而是以CSS来替代它们进行外观设置。

		被删除的标记(标签体现特殊的样式)
			<basefont>	
			<big>		
			<center>
			<font>
			<s><strike> 
			<tt>
			<u>
		删除过时的标记
			applet
			dir
			frame
			frameset	
				页面框架布局  css left right top
			noframes
		重新定义的标记
			<b>			
				代表与一本文本不同的内联文本，通常是粗体，但是没有传递表示重要的意思
			<strong>		
				表示重要性，而不是强调符号
			<dd>		
				与H5新的details与figure元素一同使用，定义包含的文本
			<dt>		
				与H5新的details与figure元素一同使用，汇总细节
			<hr>		
				表示主题结束，而不是一条水平线，虽然其表示结果是一样的
			<menu>		
				重新定义以表示用户界面菜单
			<i>			
				表示另外一种内联文本，与标准文本不同，一般以斜体显示
			<small>		
				表示小字体的打印，例如打印出的注释和法律条款
			
		被删除的属性(可以使用CSS替代这些属性的功能)
			align
			alink			(body)
			background		(body)
			bgcolor			(body,table,tr,td,th)
			border			(img,tale)
			cellpadding		(table)
			cellspacing		(table)
			height			(td,th)
			width
			hspace			(img)
			marginheight	(iframe)
			marginwidth		(iframe)
			nowrap			(td,th)
			scrolling		(iframe)
			size			(hr 	width:)
			text			(body  	color:)
			type			(li ol ul  list-style)
			valign			(tbody,td,th,thead vertical-align:)
			...

2. 新加入的元素
	对大多数Web页面制作者而言，H5最有意思的就是加入了一些新元素，虽然这些元素还没有被支持，但是很多浏览器已经先执行了一些有趣的元素，例如audio,video.而其他元素即使它们还不能被浏览器直接理解，也容易模拟。

	article 	包含文档的自己，形成文档的一个独立部分。例如一篇文章
	section		定义文档的section,包含自己的header和footer
	footer		表示一个section或者文档的页脚。
	header		表示一个section或者文档的页眉。
	hgroup		一段文字的标题元素组(h1~h6)或子标题
	nav			包含一组链接作为文档或者站点的导航
	aside		包含与其他元素包含的内容相关的内容

	功能标签
	source		表示audio和video元素使用的媒介资源
	audio		指定在Web页面中使用声音
	video		在web页面中引入一个视频
	canvas		定义使用JavaScript进行位图绘制的区域

	mark			
		表示标记文本，与在印刷文本上的突出显示的文本作用相似
	figure	
		定义一组内容作为说明，并可以使用legend元素添加标签
	time		
		包含的内容表示时间或者日期
	command		
		位于menu元素中，定义用于可以调用的命令
	datalist		
		用在input元素中，通过type="listId"来引用datalist,作为其快速选项的数据项
	details		
		定义根据需要显示的额外信息
	meter		
		定义已知范围内的度量，与刻度的意义相似
	progress	
		表示任务完成的进度，例如用进度标尺或者加载条的形式显示
	output		
		定义一个用于显示计算结果或者表单活动结果的区域
	rp	???		
		rt元素定义的ruby文本的圆括号
	rt
		定义用于发音指南的文本，该元素应该包含在ruby元素中
	ruby	
		可以包含rt和rp元素，ruby元素是发音或者读取指南，
	
3. 新加入的属性
	contenteditable	
		该属性设置为true时，浏览器应该允许用户编辑元素的内容
	hidden			
		与CSS中的display:none意义相似
	------------
	accesskey		
		定义通过键盘访问元素的快捷键
	contextmenu		
		定义menu元素的DOM id作为定义该元素特性的上下文菜单
	draggable		
		允许元素与其内容可以被拖放
	tabindex		
		在使用键盘进行导航时，定义元素的遍历顺序





	1) HTML5特点
		1. 内容类型 ContentType
			H5的文件扩展符与内容类型保持不变。扩展符为.html或.htm;内容类型为text/html
		2. DOCTYPE
			<!DOCTYPE>与之前的HTML4有很大区别，原因是HTML5并不是定义为SGML或者XML的应用程序，在HTML5中不存在有效性检查，取而代之的是根据规范来了检查规范的一致性（让浏览器按照它们应该的方式来运行）。HTML4.01中的doctype需要对DTD进行引用，因为HTML4.01基于SGML。

			HTML的语法是基于SGML(Standard Generalized Markup Language)标准通用标记语言的基础上建立起来的。由于SGML语法非常复杂，很多浏览器都不包含SGML的分析器，因此虽然HTML基本上遵从SGML语法，但是对于HTML的执行在各浏览器之间并没有统一的标准，所以浏览器本身是存在缺陷的。为了保证兼容性，H5围绕着Web标准重新定义了一套在现有HTML的基础上修改而来的语法，使它在各浏览器运行时都能符合这个标准。

		3. 指定字符编码
			H4中
				<meta http-equiv="Content-type" content="text/html;charset=UTF-8"
			H5中：
				<meta charset="UTF-8">
			两种方法均有效

		4. 确保了与之前HTML版本的兼容性

2. 新增的主体结构元素
	1) article元素
		article元素代表文档，页面或应用程序中独立的，完整的，可以独自被外部引用的内容，可以是一篇博客或者报刊中的文章，一篇论坛帖子，一段用户评论或者独立的插件，或其他任和独立的内容。
		<article>
			<header>
				<h1>苹果</h1>
				<p>发布日期：<time pubdate="pubdate">2010/10/09</time></p>
			</header>
			<p><b>苹果</b>植物类水果，多次花果.....</p>
			<footer>
				<p><small>著作版权</small></p>
			</footer>
		</article>

	2) section	
		用于对网站或应用程序中页面上的内容进行分块。一个section元素通常由内容及标题组成，但section并非是一个普通的容器元素，一个容器需要被直接定义样式或通过脚本定义行为时，推荐使用div。我们可以这样理解，section中的内容可以单独存储到数据库中或输入到word文档中。通常不推荐为那些没有标题的内容使用section元素。

		section元素的作用是对页面上的内容进行分块，或者对文章进行分段。不要与article元素混淆。article元素可以看做是一种特殊种类的section元素，比section元素更强调独立性。

		section元素的禁忌
			1. 不要将section元素用作设置样式的页面容器，那是div元素的工作。
			2. 如果article,aside,nav元素更符合使用条件，不要使用section
			3. 不要为没有标题的内容区块使用section元素。
			<article>
				<h1>WebUI课程</h1>
				<p>WebUI致力于前端开发</p>
				<section>
					<h2>HTML</h2>
					<p>用于页面结构</p>
				</section>
				<section>
					<h2>CSS</h2>
					<p>用于页面样式</p>
				</section>
			</article>
	3) nav元素
		nav元素是一个可以用作页面导航的链接组，其中导航元素链接到其他页面或当前页面的其他部分。
		nav使用的场合：
			传统导航条	
			侧边栏导航
			页内导航
			翻页操作
	4) aside元素
		aside元素用来表示当前页面或文章的附属信息部分，它可以包含当前页面或主要内容相关的引用，侧边栏，广告，导航条，以及其他类型的有别于主要内容的部分。
		aside元素主要有以下两种使用方法：
			1)被包含在article元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的参考资料，名词解释等。

			2)在article元素之外使用，作为页面或站点全局的附属信息部分。典型的形式是侧边栏，其中的内容可以是友情链接，博客中其他
		
3. 新增的非主体结构元素
	1) header元素
		是一种具有引导和导航作用的结构元素，通常用来放置整个页面或页面内的一个内容区块的标题，但也可以包含其他内容，例如数据表格，搜索表单或相关的logo图片。一个网页内并未限制header元素的个数，可以拥有多个，可以为每个内容区块加一个header元素。

		在H5中，一个header元素通常包括至少一个heading元素（h1-h6），也可以包括hgroup,table,form,nav元素
		<header>
			<hgroup>
				<h1>IT技术</h1>
				<a href="#">退出</a>
				<a href="#">[订阅]</a>
				<a href="#">[手机订阅]</a>
			</hgroup>
			<nav>
				<ul>
					<li><a href="#">WebUI</a></li>
					<li><a href="#">Java</a></li>
					<li><a href="#">Android</a></li>
					<li><a href="#">IOS</a></li>
				</ul>
			</nav>
		</header>
	2) hgroup
		是将标题以及子标题进行分组的元素，jgroup元素通常会将h1~h6元素进行分组，譬如一个内容区块的标题以及其子标题算一组。

	3) footer
		该元素可以作为其上层父级内容区块或是一个根区块的脚注。footer通常包括其相关区块的脚注信息，如作者，相关阅读连接以及版权信息等。与header类似，一个页面中也未限定footer元素的个数
		<footer>
			<ul>
				<li>版权信息</li>
				<li>站点地图</li>
				<li>联系方式</li>
			</ul>
		</footer>
	4) address
		用来在文档中呈现联系信息，包括文档作者或文档维护者名字，他们的网站链接，电子邮箱，真实地址，电话号码，以及跟文档相关的联系人的所有联系信息。

3. HTML5结构
	https://gsnedders.html5.org/outliner/
	文档大纲分析器
		
	1) 大纲的编排规则
		1. 显示编排
			指明确使用section等元素创建文档结构，在每个内容区块内使用标题(h1~h6,hgroup等)
			<section>
				<h2>标题</h2>
				<p>内容</p>
			</section>
		2. 隐式编排
			不明确使用section等元素，而是根据页面中所书写的各级标题(h1~h6,hgroup等)把各级内容区块自动创建出来。因为HTML5分析器只看到书写了某个级别的标题，就会判断存在相对应的内容区块
			<h1>网页级内容区块标题</h1>
			<p>网页级内容区块正文</p>
			<h2>section级内容区块标题</h2>
			<p>section级内容区块正文</p>

		3. 标题分级
			h1~h6,h1最高，h6最低
			如果新出现的标题比上一个标题级别低，将生成下级内容区块
			如果新出现的标题比上一个标题级别高，或者两者级别相等，将生成新的内容区块。
			<section>
				<h2>section级内容区块标题</h2>
				<p>section级内容区块正文</p>
			</section>
			<section>
				<h1>新的section级别的内容区块标题</h1>
				<p>新的section级别的内容区块正文</p>
			</section>
		4. 不同的内容区块可以使用相同级别的标题
			<body>
				<h1>网页标题</h1>
				<article>
					<header>
						<hgroup>
							<h1>文章标题</h1>
							<p>正文</p>
						</hgroup>
					</header>
				</article>
			</body>
		5. 网页编排示例
			<html>
			<head>
				
			</head>
			<body>
				<header>
					<h1>网页标题</h1>		
					<nav>
						<ul>
							<li><a href="">首页</a></li>
							<li><a href="">首页</a></li>
						</ul>
					</nav>
				</header>
				<article>
					<hgroup>
						<h1>文章主标题</h1>
						<h2>文章子标题</h2>
					</hgroup>
					<p>文章正文</p>
					<!--文章评论-->
					<section>
						<article>
							<h1>评论标题</h1>
							<p>评论正文</p>
						</article>
					</section>
				</article>
				<footer>
					<small>版权所有</small>
				</footer>
			</body>
			</html>

	2) 对新的结构元素使用样式
		因为很多浏览器尚未对HTML5新增的元素提供支持，我们无法知道客户端使用的浏览器是否支持这些元素，所以需要使用CSS追加如下声明，目的是通知浏览器页面中使用的HTML5中心增加的元素都是以块方式显示的。

		article,aside,dialog,figure,footer,header,legend,nav,section{
			display:block;
		}

4. HTML5中表单元素
	1) 新增表单元素的属性
		1.表单内元素的form属性
			在H5中，可以将表单内的从属元素书写在页面上的任何地方，然后为该元素指定一个form属性，属性值为该表单的id。
			<form id="testForm">
				<input type="text">
			</form>
			<textarea form="testForm"></textarea>

		2. formaction属性
			在H5中，可以为所有的提交按钮，诸如<input type="submit"> <input type="image"> <button type="submit">等增加不同的formaction属性，使单击不同的按钮时可以将表单提交到不同的页面。
			<form>
				<input type="submit" name="" formaction="a.action">
				<input type="submit" name="" formaction="b.action">
				<input type="submit" name="" formaction="c.action">
			</form>
			
		3. formmethod
			在H5中，可以使用formmethod属性为每个form表单元素分别指定不同的提交方法
			<form>
				<input type="text" name="name">
				<input type="submit" name="" formmethod="post">
				<input type="submit" name="" formmethod="get">
			</form>	

		4. formenctype
			在H5中，可以使用该属性对表单元素分别指定不同的编码方式
			<form>
				<input type="submit" formaction="a.action" formenctype="multipart/form-data">
			</form>
			application/x-www-form-urlencoded
			multipart/form-data	不进行编码，使用包含文件上传控件表单时，必须使用该值
			text/plain 			表单数据中的空格被转换为"+"但不对表单数据特殊字符进行编码

		5. formtarget属性
			在H5中，可以对多个提交按钮分别使用formtarget属性来指定提交后在何处打开所需要加载的页面。
				_blank		在新的浏览器窗口中打开
				_self		默认值，当前窗口中打开
				_parent		父框架中打开
				_top		当前浏览器窗口中打开
				framename	指定框架中打开

		6. autofocus属性
			为文本框选择框或按钮控件加上该属性，当画面打开时，该控件自动获得光标焦点。

		7. required属性
			在H5中，该元素可以应用在大多数元素上，在提交时，如果元素中内容为空白，则不允许提交，同时在浏览器中显示信息提示文字，提示用户必须输入内容。

		8. control属性
			在H5中，可以在标签（label元素）内部放置一个表单元素，并且通过该标签的control属性来访问该表单元素。
			<label for="oneIP" id="one">oneIp:</label>
		    <input type="text" id="oneIP">
				 ===><label for="oneIP" id="one">oneIp:<input type="text" id="oneIP"></label>
		    <script>
		        var one = document.getElementById("one");
		        one.control.value = "hello";
		    </script>

		9. placaholder属性
			是指当文本框<input type="text">或者<textarea>处于未输入状态时显示输入提示。

		10.文本框的list属性
			在H5中，可为单行文本框<input type="text">增加一个list属性，该属性值为某个datalist元素的id,datalist是H5中新增的元素，该元素类似于选择框，但是当用户想要设定的值不在选择列表之内时，允许自行输入。datalist元素本身并不显示，而是当文本框获取焦点时以提示输入的方式显示。
			<input type="search" list="list1">
		    <datalist id="list1">
		        <option value="one">one</option>
		        <option value="two">two</option>
		        <option value="three">three</option>
		    </datalist>


		11.文本框的autocomplete属性
			自动完成，该属性取值为"on"/"off"/"",当取值为on时，可以显式指定候补输入的数据列表。使用datalist元素与list属性提供候补输入的数据列表，在执行自动完成时，可以将该detalist元素中的数据作为候补输入的数据在文本框中自动显示。

			自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。     

		12.文本框的pattern属性
			将pattern属性值设为某个格式的正则表达式，在提交时会对这些进行检查，检查其内容是否符合给定格式。当输入的内容不符合给定格式时，则不允许提交，同时在浏览器中显示信息提示文字，提示输入的内容必须符合给定格式。
	・
		14.type属性(search,tel,url,email,datatime-local,data,month,week,time,number,range,color)
		新的表单域类型:
		从传统意义上，HTML的input元素用于定义大多数的表单域，表单域类型的定义是在type属性中，属性值有text,password,hidden,checkbox,radio,submit,reset,image,button另外HTML5还增加了一些其他值。

			search	
				与text文本框类似，但是用于搜索，在IOS操作系统的移动设备中，当search类型的元素获得焦点时，面板中"前往"按钮上的文字将变成"搜索"
			tel 	
				与text文本框类似，但是用于电话，在IOS操作系统的移动设备中，当tel类型的input元素获得焦点时，设备上将显示输入电话号码所使用的数字面板。
			url 	
				与text文本框类似，但是要求用户必须在其中输入url格式的内容
			email 	
				与text文本框类似，但是要求用户必须在其中输入email格式的内容
				属性
					multiple	允许该文本框输入一串以逗号分隔的email地址。
			datatime-local,data,month,week,time ,calendar	
				日期与时间输入文本框
			number 	
				数值输入文本框	
				属性
					min 	最小值
					max 	最大值
					step	步长，每次修改时增长的幅度
			range	
				只允许输入一段范围内数值的文本框，
					min 	用于设定最小值
					max		用于设定最大值。
					step	每次拖动的步幅度
			color	
				颜色选择文本框
	2) 新增表单元素
		output元素
			output元素定义不同类型的输出，比如计算结构或脚本的输出，output元素必须从属于某个表单。
			通过js来实现输出
	3) 表单验证
		1 . 自动验证
			<input type="text" required pattern=""/>
		2 . 取消验证
			1) form属性novalidate=true 可以关闭整个表单验证
			2) input/submit属性formnovalidate 可以关闭单个元素表单验证
		3 . 显式验证
			form与input元素都具有一个checkValidity方法，调用该方法可以显式地对表单内所有元素内容或单个元素内容进行有效性验证。checkValidity方法将验证结果用boolean的形式返回。

			var email = document.getElementById("email");
			email.checkValidity()	//调用方法执行校验

	3)增强的页面元素
		1 . figure元素与figcaption元素
			figure元素是一种元素的组合，带有可选标题，figure元素用来表示网页上一块独立内容，将其从网页上移除后不会对网页上的其他内容产生任何影响，figure元素所表示的内容可以是图片，统计图或代码示例，也可以是音频插件，视频插件，统计表格等。figcaption元素表示figure元素的标题，它从属于figure元素，必须书写在figure元素内部。一个figure元素内最多只允许放置一个figcaption元素，但是允许放置多个其他元素。

			<figure>
				<img src="" alt="">
				<figcaption>标题</figcaption>
			</figure>

		2 . details元素与summary元素
			details元素是一种用于标识该元素内部的子元素可以被展开,收缩显示的元素。该元素具有一个布尔类型的open属性，当该属性值为true时，该元素内部的子元素应该被展开显示；当该属性的值为false时，其内部的子元素应该被收缩起来不显示。默认值为false。details元素内并不仅限于放置文字，也可以放置表单,插件或对于一个统计图提供的详细数据表格。
			
			summary元素从属于details，用鼠标单击summary元素中的内容文字时，details元素中的其他所有从属元素将会展开或收缩。如果details元素内没有summary元素，浏览器会提供默认文字(详细信息)以供单击。

		3 . mark元素
			mark元素表示页面中需要突出显示或高亮显示的，对于当前用户具有参考作用的一段文字。通常在引用原文时使用mark元素，目的是引起读者的注意。mark元素对原文内容具有补充作用的一个元素。例如：对网页全文检索某个关键词时的检索结果；为了吸引读者注意，高亮显示
				<mark>Html 5</mark>提供了一些新的元素和属性

		4 . 新增的progress元素
			progress元素答辩一个任务的完成进度，这个进度可以是不确定的，表示进度正在进行。但是不清楚还有多少工作量没有完成，也可用0到某个最大数字（100）之间的数字来表示准确的进度完成情况（比较进度百分比）
				value	表示已经完成了多少工作量，0<value<=max
				max		表示总共有多少工作量。
		
		5 . 新增的meter元素
			meter元素表示规定范围内的数量值。例如：磁盘使用量，某个候选者的投票人数占总投票人数的比例等。
				value	:在元素中特地表示出来的实际值
				min		:指定规定范围时允许使用的最小值，默认为0
				max		:指定规定范围时允许使用的最大值，默认为1
				low		:规定范围的下限值，必须小于或等于high属性的值
				high	:规定范围的上限值
				optimum	:最佳值

				<meter value="91" min="0" max="100" high="90" low="40" optimum="100"></meter>

		6 . 改良的ol列表
			在HTML5中，将ol列表进行改良，为它添加了start属性与reversed属性。
				start		自定义开始编号
				reversed	反向编号
			<ol start=5 reversed>
				<li>内容1</li>
				<li>内容2</li>
				<li>内容3</li>
			</ol>
		7 . 改良的dl列表
			重新定义后的dl列表包含多个带有名字的列表项。每一项包含一条或多条带名字的dt元素，用来表示术语，dt元素后面紧跟一个或多个dd元素，用来表示定义。在一个元素内，不允许有相同名字的dt元素，不允许有重复的术语。也可以用来表示一些页面或article元素中内容的辅助信息，例如作者，类别等
			<article>
				<h1>article</h1>
				<p>一块独立的内容，可以用来表示RRS中一块独立的内容，也可以用来表示博客中独立的一篇文章</p>
				<aside>
					<h2>术语解释</h2>
					<dl>
						<dt>RRS</dt>
						<dd>RRS也叫聚合RRS，是在线共享内容的一种简易方式</dd>
						<dt>博客</dt>
						<dd>博客是。。。</dd>
					</dl>
				</aside>
			</article>

		8. 加以严格限制的cite元素
			cite元素表示作品的标题，该作品可以在页面中被详细引用，也可以也在页面中提一下。

			<p>我最喜欢的电影是<cite>速度与激情</cite></p>

		9. 重新定义的small元素
			专门用来标识所谓的“小字印刷体”的元素，通常用在诸如免责声明，注意事项，法律规定，与版权相关等法律性声明文字中，同时不允许应用在页面主内容中，只允许被当做辅助信息以inline方式嵌入在页面中使用。同时，small元素不意味着元素中内容字号会变小，要将字号变小，需要配合CSS样式来实现。

		10. 安全性增强的iframe元素
			H5中为iframe增加了一个sandbox属性，其作用是处于安全性方面的原因，对iframe元素内的元素内的内容是否允许显示，表单是否允许被提交以及脚本是否允许被执行等方面进行一些限制。
			sandbox=""
				1) allow-forms		
					允许iframe页面中的表单进行提交
				2) allow-scripts
					允许执行iframe页面中的JavaScript脚本代码	
				3) allow-same-origin
					当不对iframe元素使用sandbox属性时，该元素中的页面被视为与使用该iframe元素的页面来自同一个源（即使来自不同的源），允许iframe元素中的页面加载其来自服务器端的内容，允许在iframe元素所显示页面的脚本内部与服务器端进行交互，允许在iframe元素所显示的页面中加载来自cookies或者WebStorage中的内容。

					对iframe元素使用sandbox属性后，iframe元素中所显示的页面被视为来自一个单独的源（即使来自同一个）禁止上述提到的行为。

					当sandbox="allow-same-origin" 将iframe元素中的页面视为与使用该iframe元素的页面来自同一个源。通常allow-scripts，allow-same-origin连用表示在iframe元素所显示的页面中使用JavaScript脚本读取cookies或Web Storage中的内容。

				4) allow-top-navigation	
					当对iframe元素使用sandbox属性时，如果iframe元素内的页面中具有一个超链接，且单击该超链接将把浏览器窗口或iframe元素之外任何区域导航到新的内容，那么禁止该超链接
					可以通过sandbox="allow-top-navigation"使得超链接变得有效。

	
				
			11. menu
				用于创建简单的选择菜单，多数浏览器将其显示为无序列表

				属性 
					type 	
						list(默认)
						toolbar	工具栏
						context 上下文菜单，一般是单击鼠标右键时激发
			12 command
				用于创建菜单中的选项
				属性
					label	文本
					type	类型command/radio/checkbox
					icon	图标
			13 output
				用于定义一个区域，这个区域用于显示一些计算或者表单控件的结果。仅仅是一个语义元素，是可以通过传统的div来模拟
				属性
					for 	
						id of another element 	定义输出域相关的一个或多个元素。
						form 	
							formname 				定义输入字段所属的一个或多个表单。
						name 	
							unique name 			定义对象的唯一名称。（表单提交时使用）
					<form action="">
				    日期 <input type="date" id="year">
				    <br>显示：<output for="year"></output>
				</form>



媒体元素
在HTML5问世之前，要在网络上展示视频，音频，动画，除了使用第三方自主开发的播放器之外，使用得最多的工具就是Flash,但是需要在浏览器上安装各种插件，并且有时速度很慢。HTML5新增了两个与媒体相关的标签，让开发人员不必依赖任何插件就能在网页中嵌入跨浏览器的音频和视频内容，这两个标签是 <audio> <video>

1. 嵌入视/音频：
	<video src=""></video>
	<video src="" id="" width="640" height="360">视频播放器无法使用</video>
	<audio src="" id="">音频播放器无法使用</audio>
	标签之间的元素表示后备内容，在浏览器不支持这两个媒体元素的情况下显示。


2. source,指定不同媒体来源
	并不是所有的浏览器都支持所有媒体格式，可以指定多个不同的媒体来源。由于不同的浏览器支持不同的编解码器，一般要指定多种格式的媒体来源。
		src 	指播放媒体的URL地址
		type 	媒体类型，属性值为播放文件的MIME类型，该属性值中的codes参数表示所使用的媒体的编码格式。     


		<video id="video_1">
			<source src="sample.ogv" type="video/ogg">
			<source src="sample.mov" type="video/quicktime">
			视频播放器无法使用
		</video>

		<audio id="audio_1">
			<source src="" type="">
			<source src="" type="">
			音频播放器无法使用
		</audio>

3. 视频格式
	视频格式与浏览器的支持当前， <video> 元素支持三种视频格式： MP4, WebM, 和 Ogg:
	浏览器 		MP4 		WebM 	Ogg
	Internet 	Explorer 	YES 	NO 
	Chrome 		YES 		YES 	YES
	Firefox 	YES 		YES 	YES
	Safari 		YES 		NO 	NO
	Opera 		YES 	 	YES 	YES

    MP4，带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件
    WebM，带有 VP8 视频编码和 Vorbis 音频编码的 WebM 文件
    Ogg，带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件

    视频格式
		格式 	MIME-type
		MP4 	video/mp4
		WebM 	video/webm
		Ogg 	video/ogg

	检测编解码器的支持情况
	canPlayType()
		参数：	格式/编解码器字符串
		返回值：	probobly, maybe, ""

		audio.canPlayType("audio/mpeg");	
			取值可能为maybe		
		audio.canPlayType("audio/ogg; codecs=\"vorbis\"");
			取值可能为probobly


4. 自定义媒体播放器
	btn.onclick = function(){
		if(player.paused){
			player.play();
			this.value = "暂停";
		}else{
			player.pause();
			this.value = "播放";
		}
	};
	//实时更新当前播放时间
	setInterval(function(){
		curtime.innerHTML = player.currentTime;
	},250);

	<div class="mediaplayer">
		<div class="video">
			<video id="player"  width="400" height="300">
				<source src="../../video/html5.mp4" type="video/mp4">
			</video>
		</div>
		<div class="controls">
			<input type="button" id="video-btn" value="播放"/>
			当前时间：<span id="curtime">0</span>
			总时长：<span id="duration">0</span>
		</div>
	</div>
	如果想在一段音乐播放后再播放另一段音频，必须在onfinish事件处理函数中调用play()方法

5. 音/视频属性：
	src		
		指向要加载的媒体文件
	width	
		video元素独有，播放器的宽度，以像素为单位
	height	
		video元素独有，播放器的高度，以像素为单位
	poster	
		video元素独有，当视频不可用时，可以使用该元素向用户展示一副替代用的图片。
	取值为boolean类型的
		autoplay	
			取得或设置自动播放标志。
			<video src="sample.mov" autoplay></video>
		bufferingThrottled	
			浏览器是否对缓冲进行节流
		controls	
			用于显示或隐藏浏览器自带的播放用的控制条。控制条具有播放，暂停等按钮。。
			<video src="sample.mov" controls></video>
		ended
			表示媒体文件是否播放完毕
		loop
			表示媒体文件在播放完成后是否再从头开始播放(循环播放)
		muted
			媒体文件是否静音
		paused
			表示是否暂停
		seeking
			表示播放器是否正移动到媒体文件中的新位置

	取值为number类型的
		整数
		networkState
			表示当前媒体的网路连接状态，0表示空，1表示正在加载，2表示加载元数据，3表示已经加载了第一帧，4表示加载完毕
		bufferingRate	
			下载过程中每秒钟平均接收到的位数
		currentLoop	
			媒体文件已经循环的次数
		defaultPlaybackRate	浮点数
			设置或取得默认播放速度，默认为1.0秒(开发者可以改变)
		duration
			媒体的总播放事件
		totalBytes
			当前资源所需的总字节数
		videoHeight
			返回视频的高度，只适用于video
		videoWidth
			返回视频的宽度，只适用于video
		readyState
			表示媒体是否已经就绪。
			0表示数据不可用，
			1表示可以显示当前帧，
			2表示可以开始播放，
			3表示媒体可以从头到尾播放
			4表示当前播放位置已经有数据可以播放，同时也获取到了可以让播放器前进的数据，而且浏览器确认媒体数据以某一种速度进行加载可以保证有足够的后续数据进行播放

		浮点数
		currentTime	
			已经播放的秒数
		playbackRate
			取得或设置当前的播放速度(用户可以改变)
		start
			取得或者设置媒体文件中开始播放的位置，以秒为单位
		volume
			取得或设置当前音量

	取值为其他其他
		preload
			在该属性中指定音视频数据是否预加载，如果使用预加载，浏览器会预先将视频或音频数据进行缓冲，这样可以加快播放速度。
			auto 	默认值，预先加载全部视频或音频
			none 	不进行预加载
			metadata值预加载媒体的元数据(媒体字节数，第一帧，播放列表，持续时间等)
		seekable
			时间范围
			可以搜索的时间范围
		played
			时间范围
			目前为止已播放的时间
		src
			字符串
			媒体文件的来源，任何时候都需要重写这个属性
		buffered	
			时间范围
			返回一个对象，该对象实现TimeRanges接口，以确认浏览器是否已缓存媒体数据。多数情况下该对象表示的事件范围是一个单一的从0开始的范围。
		bufferedBytes	
			字节范围
			表示已下载的缓冲的字节范围的对象
		currentSrc	
			string
			当前播放的媒体文件的URL，只读属性
6. 音/视频方法
	play
		播放媒体，自动将元素的paused属性的值变为false
	pause
		暂停播放，自动将元素的paused属性变为true
	load
		重新载入媒体进行播放，自动将元素的playbackRate属性的值变为defaultPlaybackRate属性的值，自动将元素的error值变为null
	canPlayType
		用来测试浏览器是否支持指定的媒体类型
		var support = videoElement.canPlayType(type)
		参数：
			type 	参数的指定方法与source元素的type参数指定方法相同，用播放文件的MIME类型来指定，可以在指定的字符串中加上表示媒体编码格式的codes参数
		返回值
			空字符串		不支持此种媒体类型
			maybe		可能支持此种媒体类型
			probably	确认支持此种媒体类型
7. 音/视频事件
	abort	
		下载中断
	canplay
		可以播放时，readyState值为2
	canplaythrough
		播放可继续，而且应该不会中断，readyState值为3
	canshowcurrentframe
		当前帧已下载完毕，readyState值为1
	detaunavailable
		因为没有数据而不能播放；readyState值为0
	durationchange
		duration属性的值改变
	emptied
		网路连接关闭
	empty
		发生错误阻止了媒体下载
	ended
		媒体已播放到了末尾，播放停止
	error
		播放媒体发生错误时该事件被激发
		error属性
		error.code
		下载期间发生了网络错误，只读属性
		1 	:媒体数据的下载过程中由于用户操作原因而被终止
		2	:确认媒体资源可用，但是在下载时出现网路错误，媒体数据的下载被终止
		3	:确认媒体资源可用，但是解码时发生错误
		4 	:媒体资源部可用或媒体资源不被支持

	load 
		所有媒体已经加载完毕，这个事件可能废弃，建议使用canplaythrough
	loadeddata
		媒体的第一帧已经加载完毕
	loadedmetadata
		媒体的元数据已经加载完毕
	loadstart
		下载已经开始
	pause
		播放已暂停
	play
		媒体已收到指令开始播放
	playing
		媒体已实际开始播放
	progress
		正在下载
	ratechange
		播放媒体的速度改变
	seeked	
		搜索结束
	seeking
		正移动到新位置
	stalled
		浏览器尝试下载，但未收到数据
	timeupdate
		currentTime被以不合理或意外的方式更新
	volumechange
		volume属性值或muted属性值已改变
	waiting
		播放暂停。等待下载更多数据



画布：
Canvas绘图
学校目标：
	掌握canvas元素的基本概念，学会如何在页面上放置一个canvas元素，如何使用canvas元素绘制出一个简单矩形
	掌握使用路径的方法，能够利用路径绘制出圆形与多边形
	掌握渐变图形的绘制方法，学会图形变形，图形缩放，图形组合，以及给图形绘制阴影的方法
	掌握在Canvas画布中使用图像的方法，能够在画布中绘制图像，复制图像，平铺图像，裁剪图像，以及使用图像中的像素来进行图像处理的方法
	掌握如何在画布中绘制文字，给文字加上边框的方法
	掌握如何保持及恢复绘图状态，如何保存绘制出来的图形，图像，掌握在画布中制作简单动画的方法

1. 介绍
	canvas是H5中最受欢迎的功能，这个元素负责在页面中设定一个区域，然后就可以通过JS动态地在这个区域中绘制图形，canvas元素最早由苹果公司推出，当时主要用在Dashboard微件中，很快H5加入了这个元素，主要浏览器也迅速开始支持它。
2. 基本用法
	<canvas id="drawing" width="400" height="400">浏览器不支持canvas</canvas>
	位于canvas开始标签和结束标签内部的内容是后备信息，如果浏览器不支持canvas，会显示这些内容
		width	设定绘图区域的宽
		height	设定绘图区域的高
		toDataURL() 使用该方法可以导出在canvas元素上绘制的图像，这个方法接受一个参数，为图像的MIME类型格式，而且适用于创建图像的任何上下文。
		
	用canvas元素绘制图形时，需要经过几道步骤：
	1) 取得canvas对象
		通过document.getElementById()等方法取得canvas对象。
	2) 取得上下文*(context)
		图形上下文是一个封装了很多绘图功能的对象。参数只能为”2d“
		var context = one.getContext("2d");
	3) 填充与绘制边框
		使用canvas元素绘制图形的时候，有两种方式：填充与绘制边框。填充是指填满图形内部；绘制边框是指不填充图形的内部，只绘制图形的边框。canvas元素结合使用者两种方式来绘制图形。
	4) 设定绘图样式
		在进行图形绘制的时候，首先要设定好绘图的样式，然后调用有关方法进行图形的绘制，所谓绘图的样式，主要是针对图形的颜色而言的。但不仅限于图形的颜色。
			fillStyle 	填充的样式
			strokeStyle 图形边框的样式
	5) 指定线宽
		使用图形上下文对象lineWidth属性设置图形边框的宽度。
	6) 绘制矩形
		分别使用fileRect方法与strokeReck方法来填充矩形和绘制矩形边框
		context.fillRect(x,y,width,height);
		context.strokeRect(x,y,width,height);

	插件   highchars  图表

	实例：
		//获取canvas对象
	    var basic = document.getElementById("basic");
	    //获取2d绘图上下文
	    var context = basic.getContext("2d");
	    //设定填充颜色
	    context.fillStyle = "#eeeccc";
	    context.strokeStyle = "#ccceee";
	    context.lineWidth = 2;
	    //绘制- 填充
	    context.fillRect(20,200,60,-100);
	    context.fillRect(100,200,60,-140);
	    context.fillRect(180,200,60,-80);
	    context.fillRect(260,200,60,-140);
	    //绘制- 绘制线条
	    context.strokeRect(50,50,100,100);
	
3. 2D上下文
	使用2D上下文提供的方法，可以绘制简单的2D图形，比如矩形，弧线和路径。2D上下文的坐标开始于canvas元素的左上角，原点坐标是(0,0)

	1) 填充和描边
		var context = drawing.getContext("2d");	//获取上下文
		context.strokeStyle="red";	//填充
		context.fillstyle = "#ccc";	//描边
	2）绘制矩形
		矩形是唯一一种可以直接在2D上下文中绘制的形状。
		fillRect();		绘制矩形
		strokeRect();	绘制矩形框
		clearRect();	清除画布中的矩形框
		这三个方法都能接受4个参数，矩形的x坐标，y坐标，宽度，高度，这些参数的单位都是像素

		var context = drawing.getContext("2d");
		//绘制红色矩形
		context.fileStyle = "#ff0000";
		context.fillRect(10,10,50,50);

		//绘制半透明的蓝色矩形
		context.fileStyle = "rgba(0,0,255,0.5)";
		context.fileRect(30,30,50,50);

		//绘制红色描边矩形
		context.strokeStyle="red";
		context.strokeRect(10,20,100,100);

		//清除矩形
		context.clearRect(20,20,50,50);

	3) 绘制路径
		1. 绘制圆形
			1) 开始创建路径
				context.beginPath();
			2) 创建路径
				context.arc(x,y,radius,startAngle,endAngle,counterclockwise)
					x 			为绘制圆形的起点横坐标
					y			为绘制圆形的起点纵坐标
					radius 		表示弧线的半径
					startAngle	起始角度
					endAngle	结束角度
					anticlockwise	是否按顺时针方向进行绘制，true为顺时针，false为逆时针。

					在Canvas API中，绘制半径与弧时指定的参数为开始弧度与结束弧度
					角度与弧度之间的转换：
						var radians = degrees*Math.PI/180;

						Math.PI 	表示的角度为180度
						Math.PI*2	表示的角度为360度
			3) 关闭路径
				context.closePath();
				将路径关闭后，路径的创建工作就完成了。但是要注意，此时还没有真正绘制任何图形。
			4) 设定绘制样式，进行图形绘制
				//context.fillStyle = "rgba(225,0,0,0.25)";
				context.fill();		//填充图形
				context.stroke();	//绘制图形边框
			实例
				var line = document.getElementById("line");
	            var context2 = line.getContext("2d");
	            context2.fillStyle = "#ddaadd";
	            //context2.strokeStyle = "#ddaadd";
	            context2.beginPath();
	            context2.arc(100,100,50,Math.PI,Math.PI*2,true);
	            //context2.fill();
	            context2.stroke();

	    2. 绘制直线
	    	1) moveTo(x,y)
	    		将光标移动到指定坐标点，绘制直线的时候以这个坐标点为起点。
	    	2) lineTo(x,y)
	    		表示直线的终点。 x,y为终点的坐标位置。
	    	实例
	    		var line = document.getElementById("line");
	            var context3 = line.getContext("2d");
	            context3.fillStyle = "#ddaadd";
	            context3.moveTo(0,200);
	            context3.lineTo(100,100);
	            context2.closePath();
	            context3.stroke();

	    3. 绘制贝济埃曲线
	    	bezierCurveTo(c1x,c1y,c2x,c2y,x,y)
			从上一点开始绘制一条曲线，到(x,y)为止，并且以(c1x,c1y)和(c2x,c2y)为控制点
			quadraticCurveTo(cx,cy,x,y)	
			从上一点开始绘制一条二次曲线，到(x,y)为止，并且以(cx,cy作为控制点)

	4) 绘制渐变图形
		之前我们使用过fillStyle方法在填充时指定填充的颜色，该方法除了指定颜色外，还可以用来指定填充的对象。 绘制渐变时需要使用LinearGradient对象，很容易通过2D上下文来创建和修改。要创建一个新的线性渐变，可以调用createLinearGradient()方法
		1. 线性渐变
			var gradient = createLinearGradient(xstart,ystart,xend,yend)
				参数：
					xstart 	渐变起点横坐标
					ystart	渐变起点纵坐标
					xend	渐变终点横坐标
					yend	渐变终点纵坐标
				返回值：
					CanvasGradient实例
			例如
				var gradient = context.createLinearGradient(30,30,70,70);
				gradient.addColorStop(0,white);
				gradient.addColorStop(1,black);

			gradient.addColorStop(offset,color);
				参数：
					offset 	为所设定的颜色离开渐变起点的偏移量，该参数的值是一个范围在0~1之间的浮点值，渐变起始点的偏移量为0，渐变的结束点的偏移量为1
					color 	为绘制时使用的颜色
				由于是渐变，所以至少需要使用两次addColorStop方法以追加两个颜色(开始颜色和结束颜色)

			例如：
				var gradient = context.createLinearGradient(200,200,200,0);
	            gradient.addColorStop(0,'#fff');
	            gradient.addColorStop(1,'#eeeccc');
	            //设定填充颜色
	            context.fillStyle = gradient;

			function createRectLinearGradient(context,x,y,width,height){
				return context.createLinearGradient(x,y,x+width,y+height);
			}
			这个函数基于起点x和y坐标以及宽高来创建渐变对象，从而让我们可以在fillRect()中使用相同的值
		2. 径向渐变
			径向渐变是指沿着圆形的半径方向向外进行扩展的渐变方式。
			context.createRadialGradient(xstart,ystart,radiusStart,xend,yend,radiusend)
			参数：
				前三个参数：圆的原心(x,y)，以及半径
				后三个参数：终点圆的原心(x,y)，以及半径
			如果想从某个形状的中心点开始创建一个向外扩散的径向渐变的效果，就要将两个圆定义为同心圆。

	5) 绘制变形图形
		1. 坐标变换
			绘制图形的时候，我们可能经常会想要旋转图形，或者对图形进行变形处理，使用Canvas API的坐标轴变换处理功能，可以实现这种效果。
			1. 平移
				context.translate(x,y)
					参数x为坐标原点向右移动的单位，参数y为坐标原点向下移动的单位
			2. 扩大
				context.scale(x,y)
					参数x为水平方向的放大倍数，参数y为垂直方向放大的倍数，如果是缩小，将这两个参数设为0到1之间的数就可以了。
			3. 旋转
				rotate(angle)
					angle是指旋转的角度，旋转的中心点是坐标轴的原点，旋转是以顺时针方向进行的，要想逆时针旋转时，将angle设定为负数即可。
			4. 状态的保存与恢复
				save()		
					保存当前的绘图状态，save方法保存的绘图状态不仅包括当前坐标系统的状态，也包括CanvasRenderingContext2D所设置的填充风格，线条风格，阴影风格的各种绘图状态，但是save()方法不会保存当前Canvas上绘制的图形。
				restore()	恢复之前保存的绘图状态

		2. 矩阵变换（了解）
			变换矩阵是专门用来实现图形变形的，它与坐标一起配合使用，以达到变形的目的，当图形上下文被创建完毕时，实际上也创建了一个默认的变换矩阵，如果不对这个变换矩阵进行修改，那么接下来绘制的图形将以画布的最左上角为坐标原点绘制图形，绘制出来的图形也不经过缩放，变形处理，如果对这个矩阵进行修改，那么情况就不同了。
			transform(m11,m12,m21,m22,dx,dy)
				其中 m11,m12,m21,m22四个参数用来修改使用这个方法之后，绘制图形时的计算方法，以达到变形目的，dx,dy参数移动坐标原点，dx表示将坐标原点在x轴上向右移动x个单位，dy表示将坐标原点在y轴方向上向下移动y个单位。

				直接修改变换矩阵，方式是乘以如下矩阵
				m11	m12	dx
				m21	m22	dy
				0	0	1
			setTransform(m1_1,m1_2,m2_1,m2_2,dx,dy)
				将变换矩阵重置为默认状态，然后再调用transform();

	6) 图形组合
		context.globalCompositeOperation = type
		一定要用在两个图之间的代码
			//第一个图形
			context.fillStyle="lightblue";
	        context.fillRect(100,100,200,200);
	        //设定组合方式
	        context.globalCompositeOperation = "destination-out";
	        //第二个图形
	        context.fillStyle = "pink";
	        context.beginPath();
	        context.arc(150,150,100,0,Math.PI*2);
	        context.closePath();
	        context.fill();

			type的值必须是下面几种字符串之一：
			source-over	
				默认值，表示新图形覆盖在原有图形之上
			destination-over	
				在原有图形之下绘制新图形
			source-in
				新图形与原有图形作in运算，只显示新图形中与原有图形相重叠的部分，新图形与原有图形的其他部分均变为透明
			destination-in
				新图形与原有图形作in运算，只显示原有图形中与新图形相重叠的部分，新图形与原有图形的其他部分均变为透明
			source-out
				新图形与原有图形作out运算，只显示新图形与原有图形不重叠的部分，新图形与原有图形的其他部分均变为透明
			destination-out
				新图形与原有图形作out运算，只显示原有图形与新图形不重叠的部分，新图形与原有图形的其他部分均变为透明
			source-atop
				只绘制新图形与原有图形重叠的部分与未被重叠覆盖的原有图形，新图形的其他部分变为透明。
			destination-atop
				只绘制原有图形中被新图形重叠覆盖的部分与新图形的其他部分，原有图形中的其他部分变为透明，不绘制新图形中与原有图形相重叠的部分。
			lighter
				原有图形与新图形均绘制，重叠部分做加色处理。
			xor	
				只绘制新图形中与原有图形不重叠的部分，重叠部分变为透明。
			copy
				只绘制新图形，原有图形中未与新图形重叠的部分变为透明

	7) 给图形绘制阴影
		在H5中，使用Canvas元素可以给图形添加阴影效果，添加阴影效果时，只需利用图形上下文对象的几个关于阴影绘制的属性就可以了。
			shadowOffsetX
				阴影的横向位移量，默认为0
			shadowOffsetY
				阴影的纵向位移量，默认为0
			shadowColor
				阴影的颜色
			shadowBlur
				阴影的模糊范围，一般值设定在0到10之间。

	8) 使用图像
			1. 绘制图像
			在HTML5中，不仅可以使用Canvas API绘制图形，还可以读取磁盘或网络中的图像文件，然后使用Canvas API将该图像绘制在画布中。

			var image = new Image();
			image.src = "images/a.jpg";
			当图像文件是一个来源于网络的比较大的图像文件时，用户就需要耐心等待图像全部装载完毕才能看到该图像，这种情况下可以使用以下方法来解决
			image.onload = function(){
				//绘制图像的函数
			}

			context.drawImage(image,x,y);
				image为一个img元素，video元素或者一个JavaScript中的Image对象，代表实际对象来装载图像文件
				x,y为绘制时图像在画布中的起始坐标。
			context.drawImage(image,x,y,w,h);
				w,h值绘制时的图像的宽度与高度。
			context.drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh);
				可以用来将画布中已绘制好的图像的全部或者局部区域复制到画布中的另外一个位置上。
				image为被复制的图像文件
				sx,sy表示源图像的被复制区域在画布中的起始横坐标与起始纵坐标
				sw,sy表示源图像被复制区域的宽度与高度
				dx,dy表示复制后的目标图像在画布中的起始横坐标与起始纵坐标
				dw,dh表示复制后的目标图像的宽度与高度

				例如：
					context.drawImage(image,2,50,sd,sh,256,10,sd*3,sh*3);
					表示从原图中截取一部分，放大三倍后绘制到Canvas上

			createPattern(image,type)
				图像平铺
				image参数为要平铺的图像
				type的取值如下:
					no-repeat	不平铺
					repeat-x	横向平铺
					repeat-y	纵向平铺
					repeat 		全方向平铺
				返回值为pattern对象，可以为fillStyle的值
				var pattern = createPattern(image,'repeat');
				context.fillStyle = pattern;
				context.fillRect();
		2. 图像裁剪
			Canvas API的图像裁剪功能是指，在画布内使用路径，只绘制该路径所包含区域内的图像，不绘制路径外部的图像。
			context.clip();
				这个方法会把Canvas的当前路径裁剪下来，一旦调用了clip方法之后，接下来向Canvas绘制图形时，之后clip()裁剪的路径覆盖的部分才会被显示出来
			例如：
				context.beginPath();
		        context.arc(200,150,80,0,Math.PI*2);
		        context.closePath();
		        context.clip();
		        var image = new Image();
		        image.src = "../images/1.jpg";
		        image.onload = function () {
		            context.drawImage(image,0,0,400,300);
		        }
		3. 像素处理（了解）
			使用Canvas API能够获取图像中的每一个像素，然后得到该像素颜色的rgb值或rgba值。
			var imageDate = getImageData(sx,sy,sw,sh)	取得原始图像数据
				参数：
					sx,sy 要取得其数据的画面区域的x和y坐标
					sw,sh 表示获取区域的像素宽度和高度
				返回值：
					imageData是一个CanvasPixelArray对象，具有以下属性
						width	
						height
						data 	
							数组，保存着图像中每一个像素的数据。在data数组中，每个像素用4个元素来保存，分别表示红，绿，蓝，透明度值。
					取得这些像素后，就可以对这些像素进行譬如蒙版处理，面部识别等复杂的图像处理操作。
			putImageData()
				将图像数据绘制带画布上
				参数：
					ImageData的实例
					x坐标和y坐标

		4. 使用图像数据
			getImageData()
			取得原始图像数据，
				参数：
					要取得其数据的画面区域的x和y坐标
					该区域的像素宽度和高度
				返回值：
					ImageData的实例
						width	
						height
						data 	
							数组，保存着图像中每一个像素的数据。在data数组中，每个像素用4个元素来保存，分别表示红，绿，蓝，透明度值。
			putImageData()
				将图像数据绘制带画布上
				参数：
					ImageData的实例
					x坐标和y坐标

	9) 绘制文本
		fillText()		
			该方法可以使用fillStyle属性绘制文本
		strokeText()	
			该方法可以使用strokeStyle属性问文本描边
			这两个方法都可以接受4个参数：要绘制的文本字符串，x坐标，y坐标，可选的最大像素宽度。这两个方法都以下列3个属性为基础
			font			文本样式，大小，字体
			textAlign		文本对齐方式 start,end,left,right,center
			textBaseline	文本的基线，top,hanging,middle,alphabetic,ideographic,bottom

		在HTML5中，可以在Canvas画布中进行文字的绘制，同时也可以指定绘制文字的字体大小，对齐方式，文字文理填充等。
		1. 文字修饰
			font	
				设置文字字体
				context.font ="bold 30px sans-serif";
					顺序：[style] [variant] weight size family

					font-style: 
						规定字体样式。可能的值：normal，italic，oblique
					font-variant:
						规定字体变体。可能的值：normal，small-caps
					font-weight 	
						规定字体的粗细。可能的值：normal，bold，bolder，lighter，100~900
					font-size / line-height 	
						规定字号和行高，以像素计。
					font-family 	
						规定字体系列
						serif 		中文翻译为“衬线字体族”,具有末端加粗、扩张或尖细末端，或以实际的衬线结尾的一类字体。
						sans-serif 	中文翻译为“无衬线字体族”。sans-serif 字体比较圆滑，线条粗线均匀，适合做艺术字、标题等
						cursive 	中文翻译为“手写字体族”。顾名思义，这类字体的字就像手写的一样。
						fantasy 	中文翻译为“梦幻字体族”。fantasy主要用在图片中，字体看起来很艺术，实际网页上用得不多。
						monospace 	中文翻译为“等宽字体族”。我们知道英文中各字母是不等宽的，但用 monospace，各个字母就是等宽的了，就可以像中文一样排版了。
			textBaseline
				设置文字垂直对齐方式，alphabetic,top,hanging,middle,ideographic,bottom

		2. 填充文字
			fillText(text,x,y,[maxWidth])		
			该方法可以使用fillStyle属性绘制文本
			参数：
				text 	表示要绘制的文字
				x,y 	表示绘制文字的起点横坐标与纵坐标
				maxWidth表示显示文字时的最大宽度，防止文字溢出
			strokeText(text,x,y,[maxWidth])	
			该方法可以使用strokeStyle属性问文本描边
			这两个方法都可以接受4个参数：要绘制的文本字符串，x坐标，y坐标，可选的最大像素宽度。这两个方法都以下列3个属性为基础
			font			文本样式，大小，字体
			textAlign		文本对齐方式 start,end,left,right,center
			textBaseline	文本的基线，top,hanging,middle,alphabetic,ideographic,bottom
	
	10) 输出位图
		当在Canvas上绘图完成后，还可以调用如下方法输出位图
		canvas.toDataURL(String type)
			该方法把Canvas对应的位图编码成DataURL格式的字符串。DataURL格式是一种保存二进制文件方式，我们既可以将图片转换为DataURL格式的字符串，也可以把DataURL格式的字符串恢复成原来的文件。
			type为形如"image/png"格式的MIME字符串

			var result = document.getElementById("result");
        	result.src = canvas.toDataURL("image/png");

        	<img src="" alt="图片找不到" id="result">

	

一.拖放API
拖放是一种常见的特性，即抓取对象以后拖到另一个位置。虽然在HTML5之前已经可以使用mousedown,mousemove,mouseup实现拖放，但是只支持在浏览器内部的拖放，在HTML5中，拖放是标准的一部分，任何元素都能够拖放，并且支持浏览器与其他应用程序之间的数据的互相拖放，同时大大简化了拖放方面的相关代码。

学习内容：
	掌握怎么样利用拖放API使页面中的元素可以相互拖放
	掌握DataTransfer对象的属性和方法
	掌握怎样设定拖放时的视觉效果
	掌握怎样自定义拖放目标

	1. 实现拖放
		在H5中要想实现拖放操作，至少需要经过两个步骤：
		1) 将想要拖放的对象元素的draggable属性设为true,另外img与a元素默认允许拖放
		2) 编写与拖放相关的事件处理代码
		例如：
			<section>
		        <h2>基本使用</h2>
		        <div id="source" draggable="true">请拖拽我</div>
		        <hr>
		        <div id="target"></div>
		    </section>
		    <section>
        
		    <script>
		        var source = document.getElementById("source");
		        var target = document.getElementById("target");
		        //该方法在拖拽的时候激发，不能阻止事件默认行为，否者将不会出现拖拽效果,为了能在火狐中实现拖拽效果，必须获取dataTransfer
		        source.ondragstart = function (event) {
		            console.log("start-开始移动");
		            var data = event.dataTransfer;
		            data.setData("text/plain",this.id);
		        };
		        //为了兼容google浏览器与safari浏览器必须重写
		        target.ondragover = function (event) {
		            event.preventDefault();
		        }
		        target.ondrop = function (event) {
		            console.log("drop-放开");
		            var id = event.dataTransfer.getData("text/plain");
		            var source = document.getElementById(id);
		            this.appendChild(source);
		            event.preventDefault();
		            //在Firefox中阻止新页面的打开
		            event.stopPropagation();
		        }
		    </script>

	2. 拖放事件
		通过拖放事件，可以控制拖放相关的各个方面。其中最关键的地方在于确定哪里发生了拖放事件，有些事件是在被拖动的元素上触发的，有些事件是在放置目标上触发的。

		1) 拖动事件。
			dragstart
				按下鼠标并开始移动鼠标时，会在拖放的元素上触发dragstart事件。此时光标变成了“不能放”符号（圆环中有一条反斜线），表示不能把元素放到自己上面。可以通过ondragstart事件处理程序来运行JavaScript代码
			drag
				触发dragstart事件后，随即会触发drag事件，而且在元素被拖动期间会持续触发该事件（类似mousemove事件）。
			dragend
				当拖放停止时(无论是把元素放到了有效的放置目标，还是放置到了无效的放置目标上)都会触发dragend事件。

		2) 放置事件
			dragenter
				只要有元素被拖动到放置目标上，就会触发dragenter事件（类似mourseover事件）
				元素被拖出了放置目标，会触发dragleave
			dragover
				dragenter紧随其后的就是dragover事件，而且在被拖动的元素还在放置目标的范围内移动时，就会持续触发该事件。
			drop
				将拖动元素放置到目标元素上的时候会激发。

		3) 拖放事件生命周期
			dragstart->drag->dragenter->dragover->drop->dragend

	3. 自定义放置目标
		有些元素不允许放置目标元素，但是我们可以将个\元素变成有效的放置目标。方法是和dragover事件的默认行为。
	4. dataTransfer对象
		在拖放操作时实现数据交换，它是事件对象的一个属性，用于从被拖拽元素向放置目标传递字符串格式的数据。因为它是事件对象的属性，所以只能在拖放事件的事件处理程序中访问dataTransfer对象。
		1)获取方式
			event.dataTransfer
		2)方法
			dataTransfer.getData(key);
				获取由setData保存的值
			dataTransfer.setData(key,val);
				在dataTransfer中设置值，H5对其允许指定各种MIME类型为：text/plain; text/html; text/xml; text/uri-list。
			clearData(format)
				从DataTransfer对象或ClipboardData对象中删除指定格式或全部kind值为string的数据。仅在dragstart事件中调用，在其他事件中调用会抛InvalidStateError。
			setDragImage(element,x,y)
				指定一幅图像，当拖放发生的时候，显示在光标下方。
		3)属性
			effectAllowed
				该属性与dropEffect属性结合起来可以设定拖放时的视觉效果。effectAllowed属性表示当一个元素被拖动时允许的视觉效果，一般在ondragstart事件中设定。
				取值：
					copy 	限定dropEffect的属性值为copy，否则会鼠标指针为禁止样式
		　   　  	link 	限定dropEffect的属性值为link，否则会鼠标指针为禁止样式
		           	move 	限定dropEffect的属性值为move，否则会鼠标指针为禁止样式
		           	copyLink限定dropEffect的属性值为copy和link，否则会鼠标指针为禁止样式
		           	copyMove限定dropEffect的属性值为copy和move，否则会鼠标指针为禁止样式
		           	linkMove限定dropEffect的属性值为link和move，否则会鼠标指针为禁止样式
		　　     	all 	允许dropEffect的属性值为任意值
		           	none 	鼠标指针一直为禁止样式，不管dropEffect的属性值是什么
		           	uninitialized 	没有限定dropEffect属性的值，效果和 all 一样。
		        注意：
		        	仅能在dragstart事件中设置该属性，其他事件中设置均无效。

			dropEffect
				用于设置目标元素将执行的操作，表示实际拖放时的视觉效果，一般在ondragover事件中指定。若属性值属于effectAllowed范围内，则鼠标指针将显示对应的指针样式，否则则显示禁止的指针样式。
				取值：
					link 	被拖拽元素将以超链接的形式打开资源，若属于effectAllowed范围内时，则鼠标指针显示超链接的样式，否则则显示禁止的指针样式。
		            move 	被拖拽元素将被移动到目标元素内，若属于 effectAllowed   范围内时，则鼠标指针显示移动的样式，否则则显示禁止的指针样式。
		            none 	被拖拽元素不能在目标元素上作任何操作，一直显示禁止的指针样式。除了文本框外其他元素的默认值均为none
		        注意：
		        	1) 仅能在 dragover 事件中设置该属性值，其他事件中设置均无效
		　　			2) 当显示禁止的指针样式时，将无法触发目标元素的 drop 事件。
			types
				数据类型为DOMStringList，存储DataTransfer对象中所有数据项的数据类型
			items
				数据类型为DataTransferItemList，存储DataTransfer对象中所有的数据项

	5. 实例代码
		var source = document.getElementById("dragme");
        var desc = document.getElementById("text");
        //拖放开始
        source.ondragstart = function (ev) {
            var img = document.createElement("img");
            img.src = "../images/one.png";
            var dt = ev.dataTransfer;
            dt.effectAllowed = "move";
            dt.setData("text/plain",this.id);
            dt.setDragImage(img,0,0);
        };
        desc.ondrop = function (ev) {
            var dt = ev.dataTransfer;
            var id = dt.getData("text/plain");
            var target = document.getElementById(id);
            this.appendChild(target)
            ev.preventDefault();
            ev.stopPropagation();
        }
        desc.ondragover = function (ev) {
            var dt = ev.dataTransfer;
            dt.dropEffect = "move";
            ev.preventDefault();
        }

		<div id="dragme" draggable="true">
		    请拖放
		</div>
		<div id="text">





二.离线应用与客户端存储
学习内容：
	掌握什么是离线Web应用程序？为什么要开发离线Web应用程序？掌握什么是本地缓存，本地缓存与网页缓存有什么区别？
	掌握什么是manifest文件，怎么样在manifest文件中指定哪些内容需要进行本地缓存，哪些不需要？
	掌握进行本地缓存时所使用到的applicationCache对象，怎么样利用这个对象的swapCache方法来手工更新本地缓存？

	1. 什么是离线Web应用？
		所谓离线Web应用，就是在设备不能上网的情况下，仍然可以运行的应用。前端开发者一直希望Web应用能够与传统的客户端应用同场竞技。为了让Web应用程序在离线状态时也能正常工作，就必须要把所有构成Web应用程序的资源文件，如HTML文件，CSS文件，JavaScript脚本文本等放到本地缓存中，当服务器没有和Internet建立连接的时候，也可以利用本地缓存中的资源文件来正常运行Web应用程序。

	2. 本地缓存与浏览器网页缓存的区别？
		1) 本地缓存是为整个Web应用程序服务的，而浏览器的网页缓存只服务于单个网页，任何网页都可以进行网页缓存，而本地缓存只缓存哪些你指定的缓存网页
		2) 网页缓存是不安全，不可靠的。而本地缓存是可靠的，我们可以控制对哪些内容进行缓存，哪些不进行，开发人员开可以利用编程的手段来控制缓存的更新。

	3. manifest文件
		manifest文件是一个简单文本文件，在该文件中以清单的形式列举了需要被缓存或不需要被缓存的资源文件的文件名称，以及这些资源文件的访问路径。你可以为每个页面单独制定一个manifest文件，也可以对整个Web应用程序指定一个总的manifest文件。
		在H5中规定manifest文件的MIME类型是text/cache-manifest，在测试离线Web应用程序的时候，需要对服务器进行配置，让服务器支持text/cache-manifest这个MIME类型，例如在Apache服务器进行配置的时候，需要找到{apache_home}/conf/mime.types这个文件，并在文件最后添加如下代码

			text/cache-manifest 	manifest

		例如：
		index.html

			CACHE MANIFEST
			CACHE:
			other.html
			hello.js
			images/myphoto.jpg
			NETWORK:
			*
			FALLBACK:
			online.js locale.js

		1) 在manifest文件中，第一行必须是CACHE MANIFEST
		2) 指定资源文件时，文件路径可以是相对路径也可以是绝对路径，每个资源文件为一行。并且可以将资源文件分为三类：
			CACHE
				指定需要被缓存在本地的资源文件。
			NETWORK
				指定不进行本地缓存的资源文件。这些资源文件只有当客户端与服务器端建立连接的时候才能访问。"*"表示没有在本minifest文件中指定的资源文件都不进行本地缓存。
			FALLBACK
				每行指定两个资源文件，第一个资源文件为能够在线访问时使用的资源文件，第二个资源文件为不能在线访问时候使用的备用资源文件。
		3) 为了让浏览器能够正常阅读该文本文件，需要在Web应用程序页面上的html标签的manifest属性中指定manifest文件的URL地址。
			<html manifest="global.manifest">
			
			</html>
			当要对本地缓存区的内容进行修改时，只需要修改manifest文件就可以了，文件被修改后，浏览器可以自动检查manifest文件，并自动更新本地缓存区中的内容。
		4) 在Chrome中，可以使用 查看你chrome://appcache-internals/ 缓存在本地的资源文件。
	4. applicationCache对象
		该对象代表了本地缓存，可以用它来通知用户本地缓存中已经被更新，也允许用户手工更新本地缓存。
		1) 事件
			checking		在浏览器为应用缓存查找更新时触发
			error			在检查更新或下载资源期间发生错误时激发
			noupdate		在检查描述文件发现文件无变化时触发
			downloading		在开始下载应用缓存资源时触发,在文件下载应用缓存的过程中不断触发
			cached			在应用缓存完整可用的时候触发
			updateready		当浏览器对本地缓存进行更新，装入新的资源文件时，会触发applicationCache对象的updateready事件，通知本地缓存已经被更新。用户需要手工刷新页面来得到最新版本的应用程序。
		2) 方法
		 	applicationCache.swapCache()
				用来手工立即执行本地缓存的更新，它只能在applicationCache对象的updateReady事件触发时调用。
			applicationCache.update()
				检查服务器上的manifest文件是否有更新
		3) 属性
			status	
				0	无缓存
				1	闲置
				2	检查中
				3	下载中
				4	更新完成
二.数据存储
	随着Web应用的出现，也产生了对于能够直接在客户端上存储用户信息能力的要求。由于cookie与IE中提供的持久化用户数据的容量限制以及数据安全问题，不能大量存储数据和安全数据，H5中提供了Web Storage
	学习内容：
		掌握Web Storage的基本概念，了解sessionStorage和localStorage使用方法以及区别
		掌握使用sessionStorage和localStorage进行数据存储，对象存储的方法
		掌握本地数据库的基本概念。掌握SQLLite本地数据库的基本概念以及其使用方法
		掌握IndexedDB数据库的基本概念以及其使用方法

	1. Web Storage
		Web Storage最早在Web超文本应用技术工作组（WHAT-WG）的Web应用1.0规范中描述的，这个规范的最初的工作最终成为了HTML5的一部分，WebStorage的目的是克服由cookie带来的一些限制，当数据需要被严格控制在客户端上时，无须持续将数据发回服务器。
		1) 使用cookie的限制
			1. cookies的大小被限制在4KB
			2. cookies是随HTTP事务一起被发送的，因此会浪费一部分发送cookies时使用的带宽
			3. 要正确操纵cookies是很困难的

		2) WebStorage的两个目标是：
			提供一种在cookie之外存储会话数据的途径
			提供一种存储大量可以跨会话存在的数据的机制

		3) Storage类型
			Storage类型提供了大量的存储空间来存储键值对，Storage实例与其他对象类似，Storage类型只能存储字符串，非字符串的数据在存储之前会被转换成字符串。
			Storage对象提供的方法
				setItem(name,value)	为指定的name设置一个对应的值
				getItem(name)		根据指定的名字name获取对应的值
				removeItem(name)	删除由name指定的键值对
				clear() 			
				删除所有值;
				key(index)			获得index位置处的值的名字
				length				Storage对象中，键值对的数量
			Storage对象提供的事件
				当在【其他页面】中修改sessionStorage或者localStorage中的值时要执行的处理
				storage
					event.key		被修改的数据键值	
					event.oldValue 	被修改前的值
					event.newValue 	被修改后的值
					event.url 		页面的URL地址
					event.storageArea 	为变动的sessionStorage对象或localStorage对象
			Web Storage分为两种：
			1. sessionStorage对象
				将数据保存在session对象中。session是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要保存的任何数据。(仅限当前选项卡)
			2. localStorage
				将数据保存在客户端本地的硬盘设备中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。

--------------------------------------------------------
附：
1. Http Cookie
	通常直接叫做cookie，最初是在客户端用于存储会话信息的，该标准要求服务器对任意HTTP请求发送Set-Cookie HTTP头作为响应的一部分，其中包含会话信息，例如，这种服务器响应的头可能如下：
		HTTP/1.1 200 OK
		Content-type:text/html
		set-Cookie: name=value
		Other-header:other-header-value
	这个HTTP响应设置以name为名称，以value为值得一个cookie，名称和值在传送时都必须是URL编码的。浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加Cookie Http头将信息发送回服务器
		GET /index.html HTTP/1.1
		Cookie: name=value
		other-header: other-header-value
	发送回服务器的额外信息可以用于唯一验证客户来自发送的哪个请求。

	1. 限制
		由于Cookie是存在客户端计算机上，还加入了一些限制确保cookie不会被恶意使用，同时不会占用太多磁盘空间，每个域上的cookie总数是有限的，每个浏览器不同。
			IE6-	20
			IE7+	50
			Firefox 50
			Opera 	30
			Safari 	没有规定
			Chrome  没有规定
		当超过单个域名限制之后还要载设置cookie，浏览器就会清除以前设置的cookie

	2. 构成
		名称	不区分大小写，唯一
		值 	存储在cookie中的字符串值，值必须被URL编码
		域	cookie对于哪个域是有效的 .wrox.com
		路径	对于指定域中的那个路径，应该向服务器发送cookie	
				http://www.wrox.com/books  	指定路径，可以访问
				http://www.wrox.com 	    不可以访问
		失效时间	默认情况下，浏览器会话结束时会将所有cookie删除，但是也可以自己设置时间，时间值为GMT格式日期（Wdy,DD-Mon-YYYY HH:MM:SS GMT）
		安全标志 	指定后，cookie只有在使用SSL连接时才发送到服务器

			Set-Cookie: name=value; expires=Mon,22-Jan-07 07:10:24 GMT; domain=.wrox.com; path=/; secure

	3. JavaScript中的cookie
		在js中处理cookie比较复杂，使用BOM的document.cookie属性
	4. 关于cookie的思考
		由于所有的cookie都会由浏览器作为请求头发送，所以在cookie中存储了大量信息会影响到特定域的请求性能。cookie信息越大，完成服务器响应时间就越长，并且不能再cookie中存储如银行卡或个人信息之类的数据，安全性不能保证。

	
三.通知API(了解)
通知API允许在某个事件（例如接收到Email邮件，接收到公告信息等事件）中向用户显示通知信息，无论用户正在查看哪一个浏览器标签页中的内容，只要有一个浏览器标签页面中接收到通知信息，浏览器中就会将其显示。
	1. 实现过程
		1) 检查浏览器是否支持通知API
			目前只有Chrome6以上版本与Safari5.2以上版本的浏览器支持通知API
			if(window.webkitNotifications){
				//支持
			}

		2) 向用户请求让浏览器显示通知的权限
			为了让浏览器可以显示通知，我们首先要向用户请求让浏览器显示通知的权限。
			window.webkitNotifications.requestPermission();
			 	该方法只在用户显式触发的事件中有效。
			window.webkitNotifications.checkPermission();
				该方法用来判断用户是否给予让浏览器显示通知的权限。

			document.getElementById("showBtn").onclick = function(){
				window.webkitNotifications.requestPermission();
				window.webkitNotifications.checkPermission()	
			};
		3) 创建通知
			notification = window.webkitNotifications.createNotification(
	                            'images/rails.png', // 图标路径 - 可以是相对路径
	                            '通知', 				// 通知的标题
	                            '哈哈，你中彩咯！' 		// 通知的内容
	                    );
	        window.webkitNotifications.createHTMLNotification(
	                            'xxx.html'			 // HTML路径 - 可以是相对路径	
	                    );
	    4) 通知显示
	    	notification.show();

	    	事件
	    	notification.ondisplay = function() {
	    		//当通知被显示时触发
	        };
	        notification.onclose = function() {
	        	//当通知被关闭时触发
	        };
	2. 实例
		function createNotification(options) {
	        if (options.notificationType == 'simple') {
	            // 创建一个文本通知:
	            return window.webkitNotifications.createNotification(
	                    'images/rails.png', // 图标路径 - 可以是相对路径
	                    '通知', 				// 通知的标题
	                    '哈哈，你中彩咯！' 		// 通知的内容
	            );
	        }
	        else if (options.notificationType == 'html') {
	            // 或者创建一个HTML通知:
	            return window.webkitNotifications.createHTMLNotification(
	                    'xxx.html'	// HTML路径 - 可以是相对路径
	            );
	        }
	    }

	    document.querySelector('#showBtn').addEventListener('click', function() {
	        if (window.webkitNotifications.checkPermission() == 0) {
	            // 0 表示允许Notifications
	            notification = createNotification({notificationType: 'simple'});
	            notification.ondisplay = function() {
	                console.log("display");
	            };
	            notification.onclose = function() {
	                console.log("close");
	            };
	            notification.show();
	            setTimeout('notification.cancel()', 4000)
	        } else {
	            window.webkitNotifications.requestPermission();
	        }
	    }, false);




1. 本地数据库
	在HTML4中，数据库只能放在服务器端，只能通过服务器来访问数据库，但是在HTML5中，可以向访问本地文件那样轻松地对内置数据库进行访问。在HTML5中内置了两种本地数据库，一种为"SQLLite",可以通过SQL语言来访问的文件型SQL数据库。另外一种为"indexedDB"的NoSQL类型的数据库。到目前为止Chrome6+，Opera10+，Safari5+ 的浏览器对SQLLite数据库提供支持。

	但是sqlLite是一个废弃的标准了，虽然部分浏览器已经实现

	1) 访问方式
		1. 使用openDatabase方法创建一个访问数据库的对象
			var db = openDatabase("mydb",1.0,'Test DB',2*1024*1024)
		2. 使用事务处理
			db.transaction(function(tx){
				tx.executeSql();
			});
	2) API
		openDatabase(dbName,version,desc,size)
			参数分别为数据库名，版本号，数据库的描述，数据库的大小
			返回值为创建后的数据库访问对象，如果数据库不存在，则创建该数据库
		transaction(fun)
			执行事务处理，使用事务处理，可以防止在对数据库进行访问以及执行有关操作时受到外界的干扰。
			参数为回调函数，在该回调函数中，执行访问数据库的语句
		transaction.executeSql(sql,[],dataHandler,errorHandler);
			sql 	需要执行的SQL语句
			[] 		sql中所有使用到的参数的数组，sql语句中可以使用占位符?进行替代
			dataHandller	成功执行SQL语句时调用的回调函数
				function dataHandler(transaction,results){
					//transaction 对象
					//执行查询操作时返回的查询到的结果数据集对象
				}
			errorHandler 	执行SQL语句出错时调用的回调函数
				function errorHandler(transaction,errmsg){
					//transaction
					//执行发生错误时的错误信息文字
				}

3. indexedDB
	该数据库是一种存储在客户端本地的NoSQL数据库，目前Firefox4+，IE10，Chrome11+对其提供了支持
	一个网站可能有一个或多个 IndexedDB 数据库，每个数据库必须具有惟一的名称。一个数据库可包含一个或多个对象存储。一个对象存储（由一个名称惟一标识）是一个记录集合。每个记录有一个键 和一个值。该值是一个对象，可拥有一个或多个属性。键可能基于某个键生成器，从一个键路径衍生出来，或者是显式设置。一个键生成器自动生成惟一的连续正整数。键路径定义了键值的路径。它可以是单个 JavaScript 标识符或多个由句点分隔的标识符。

	1) 数据库的链接
		var idb;
		var dbConnect = indexedDB.open(dbName,version);
		dbConnect.onsuccess = function(event){
			idb = event.target.result;//event.target.result是一个IDBDatabase对象，代表链接成功的数据库对象
		};
		dbConnect.onerror = function(){
			alert("链接失败");
		};
		//版本更新事件
		dbConnect.onupgradeneeded = function(e){
			idb = event.target.result;
			var tx = e.target.transaction;//IDBTransaction事务对象，代表版本更新事务
			var oldVersion = e.oldVersion;
			var newVersion = e.newVersion;
			alert("数据库版本更新成功！久版本为"+oldVersion+",新版本为"+newVersion);
		}
	2)数据库的关闭
		idb.close();
		当数据库连接被关闭后，不能再继续执行任何对该数据库进行的操作，否则浏览器将抛出InvalidStateError的异常。
	3)创建对象仓库
		在VERSION_CHANGE事务中进行，
		dbConnection.onupgradeneeded = function(e){
			idb = e.target.result;
			var tx = e.target.transaction;
			//创建对象仓库
			var store = idb.createObjectStore("Users",{
				keyPath:"userId",
				autoIncrement:false
			});
		};
	4)创建用于检索的索引
		在VERSION_CHANGE事务中进行
		在indexedDB数据库中，只能针对被设为索引的属性值进行检索，不能针对没有被设为索引的属性值进行检索。
		dbConnection.onupgradeneeded = function(e){
			idb = e.target.result;
			var tx = e.target.transaction;
			//创建对象仓库
			var store = idb.createObjectStore("Users",{
				keyPath:"userId",
				autoIncrement:false
			});
			//创建索引
			var idx = store.createIndex("userNameIndex","userName",{
				unique:false,
				multiEntry:false
			});
		};
	5)事务
		在使用indexedDB数据库时，所有对于数据的操作都在一个事务内部执行。事务分为三种：
		READ_ONLY	只读事务
		READ_WRITE 	读写事务
		VERSION_CHANGE 	版本更新事务
		
附：
indexedDB预定义
	window.indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;

	window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;

	window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;

	window.IDBCursor = window.IDBCursor || window.webkitIDBCursor || window.msIDBCursor;
